### This file was generated by Nexus Schema
### Do not make changes to this file directly


type Account {
  createdAt: DateTime!
  currency: Currency!
  deletedAt: DateTime
  id: String!
  name: String!
  operations(after: OperationWhereUniqueInput, before: OperationWhereUniqueInput, first: Int, last: Int, orderBy: [OperationOrderByInput!], where: OperationWhereInput): [Operation!]!
  updatedAt: DateTime!
  user: User!
  userId: String!
}

input AccountCreateInput {
  currency: Currency
  name: String!
}

input AccountListRelationFilter {
  every: AccountWhereInput
  none: AccountWhereInput
  some: AccountWhereInput
}

input AccountOrderByInput {
  createdAt: SortOrder
  currency: SortOrder
  deletedAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
  user: UserOrderByInput
  userId: SortOrder
}

input AccountUpdateInput {
  currency: Currency
  name: String!
}

input AccountWhereInput {
  AND: [AccountWhereInput!]
  createdAt: DateTimeFilter
  currency: EnumCurrencyFilter
  deletedAt: DateTimeNullableFilter
  id: StringFilter
  name: StringFilter
  NOT: [AccountWhereInput!]
  operations: OperationListRelationFilter
  OR: [AccountWhereInput!]
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

input AccountWhereUniqueInput {
  id: String
}

type AuthPayload {
  token: String
  user: User
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

type CategoriesResult {
  data: [Category]
  pagination: Pagination
}

type Category {
  createdAt: DateTime!
  deletedAt: DateTime
  id: String!
  name: String!
  operations(after: OperationWhereUniqueInput, before: OperationWhereUniqueInput, first: Int, last: Int, orderBy: [OperationOrderByInput!], where: OperationWhereInput): [Operation!]!
  type: TransactionType!
  updatedAt: DateTime!
  user: User!
}

input CategoryCreateInput {
  name: String!
  type: TransactionType!
}

input CategoryListRelationFilter {
  every: CategoryWhereInput
  none: CategoryWhereInput
  some: CategoryWhereInput
}

input CategoryOrderByInput {
  createdAt: SortOrder
  deletedAt: SortOrder
  id: SortOrder
  name: SortOrder
  type: SortOrder
  updatedAt: SortOrder
  user: UserOrderByInput
  userId: SortOrder
}

input CategoryUpdateInput {
  name: String!
  type: TransactionType!
}

input CategoryWhereInput {
  AND: [CategoryWhereInput!]
  createdAt: DateTimeFilter
  deletedAt: DateTimeNullableFilter
  id: StringFilter
  name: StringFilter
  NOT: [CategoryWhereInput!]
  operations: OperationListRelationFilter
  OR: [CategoryWhereInput!]
  type: EnumTransactionTypeFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

input CategoryWhereUniqueInput {
  id: String
}

enum CreditCardBrand {
  AmericanExpress
  BNDES
  Dinners
  ELO
  HiperCard
  MasterCard
  Other
  SoroCard
  Visa
}

input CreditCardListRelationFilter {
  every: CreditCardWhereInput
  none: CreditCardWhereInput
  some: CreditCardWhereInput
}

input CreditCardOrderByInput {
  brand: SortOrder
  createdAt: SortOrder
  deletedAt: SortOrder
  id: SortOrder
  limit: SortOrder
  name: SortOrder
  updatedAt: SortOrder
  user: UserOrderByInput
  userId: SortOrder
}

input CreditCardWhereInput {
  AND: [CreditCardWhereInput!]
  brand: EnumCreditCardBrandFilter
  createdAt: DateTimeFilter
  deletedAt: DateTimeNullableFilter
  id: StringFilter
  limit: FloatFilter
  name: StringFilter
  NOT: [CreditCardWhereInput!]
  operations: OperationListRelationFilter
  OR: [CreditCardWhereInput!]
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

enum Currency {
  BRL
  EUR
  GBP
  USD
}

"""
A date string, such as 2007-12-03, compliant with the `full-date` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar Date

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input EnumCreditCardBrandFilter {
  equals: CreditCardBrand
  in: [CreditCardBrand!]
  not: NestedEnumCreditCardBrandFilter
  notIn: [CreditCardBrand!]
}

input EnumCurrencyFilter {
  equals: Currency
  in: [Currency!]
  not: NestedEnumCurrencyFilter
  notIn: [Currency!]
}

input EnumLocaleFilter {
  equals: Locale
  in: [Locale!]
  not: NestedEnumLocaleFilter
  notIn: [Locale!]
}

input EnumTransactionTypeFilter {
  equals: TransactionType
  in: [TransactionType!]
  not: NestedEnumTransactionTypeFilter
  notIn: [TransactionType!]
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

enum Locale {
  enUS
  ptBR
}

type Mutation {
  changePassword(hash: String!, password: String!): String
  checkHashEmail(hash: String!): String
  createOneAccount(data: AccountCreateInput!): Account!
  createOneCategory(data: CategoryCreateInput!): Category!
  createOneOperation(data: OperationCreateInput!): Operation!
  deleteOneAccount(where: AccountWhereUniqueInput!): Account
  deleteOneCategory(where: CategoryWhereUniqueInput!): Category
  deleteOneOperation(where: OperationWhereUniqueInput!): Operation
  login(email: String!, password: String!): AuthPayload
  register(user: RegisterInput!): String
  requestChangePassword(email: String!): String
  restoreOneAccount(where: AccountWhereUniqueInput!): Account
  restoreOneCategory(where: CategoryWhereUniqueInput!): Category
  restoreOneOperation(where: OperationWhereUniqueInput!): Operation
  updateOneAccount(data: AccountUpdateInput!, where: AccountWhereUniqueInput!): Account!
  updateOneCategory(data: CategoryUpdateInput!, where: CategoryWhereUniqueInput!): Category!
  updateOneOperation(data: OperationUpdateInput!, where: OperationWhereUniqueInput!): Operation!
  updateOneUser(user: UserUpdateInput!): User!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input NestedEnumCreditCardBrandFilter {
  equals: CreditCardBrand
  in: [CreditCardBrand!]
  not: NestedEnumCreditCardBrandFilter
  notIn: [CreditCardBrand!]
}

input NestedEnumCurrencyFilter {
  equals: Currency
  in: [Currency!]
  not: NestedEnumCurrencyFilter
  notIn: [Currency!]
}

input NestedEnumLocaleFilter {
  equals: Locale
  in: [Locale!]
  not: NestedEnumLocaleFilter
  notIn: [Locale!]
}

input NestedEnumTransactionTypeFilter {
  equals: TransactionType
  in: [TransactionType!]
  not: NestedEnumTransactionTypeFilter
  notIn: [TransactionType!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

type Operation {
  account: Account!
  accountId: String!
  category: Category
  categoryId: String
  createdAt: DateTime!
  deletedAt: DateTime
  id: String!
  isPaid: Boolean!
  name: String!
  paidAt: DateTime
  type: TransactionType!
  updatedAt: DateTime!
  user: User!
  userId: String!
  value: Float!
}

input OperationCreateInput {
  accountId: String!
  categoryId: String
  isPaid: Boolean!
  name: String!
  paidAt: DateTime
  type: TransactionType!
  value: Float!
}

input OperationListRelationFilter {
  every: OperationWhereInput
  none: OperationWhereInput
  some: OperationWhereInput
}

input OperationOrderByInput {
  account: AccountOrderByInput
  accountId: SortOrder
  category: CategoryOrderByInput
  categoryId: SortOrder
  createdAt: SortOrder
  creditCard: CreditCardOrderByInput
  creditCardId: SortOrder
  deletedAt: SortOrder
  id: SortOrder
  isPaid: SortOrder
  name: SortOrder
  paidAt: SortOrder
  type: SortOrder
  updatedAt: SortOrder
  user: UserOrderByInput
  userId: SortOrder
  value: SortOrder
}

input OperationUpdateInput {
  accountId: String!
  categoryId: String
  isPaid: Boolean!
  name: String!
  paidAt: DateTime
  type: TransactionType!
  value: Float!
}

input OperationWhereInput {
  account: AccountWhereInput
  accountId: StringFilter
  AND: [OperationWhereInput!]
  category: CategoryWhereInput
  categoryId: StringNullableFilter
  createdAt: DateTimeFilter
  creditCard: CreditCardWhereInput
  creditCardId: StringNullableFilter
  deletedAt: DateTimeNullableFilter
  id: StringFilter
  isPaid: BoolFilter
  name: StringFilter
  NOT: [OperationWhereInput!]
  OR: [OperationWhereInput!]
  paidAt: DateTimeNullableFilter
  type: EnumTransactionTypeFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
  value: FloatFilter
}

input OperationWhereUniqueInput {
  id: String
}

type Pagination {
  totalItems: Int
}

type Query {
  findManyAccount(cursor: AccountWhereUniqueInput, orderBy: [AccountOrderByInput], skip: Int, take: Int, where: AccountWhereInput): [Account!]!
  findManyCategory(cursor: CategoryWhereUniqueInput, orderBy: [CategoryOrderByInput], skip: Int, take: Int, where: CategoryWhereInput): CategoriesResult!
  findManyOperation(cursor: OperationWhereUniqueInput, orderBy: [OperationOrderByInput], skip: Int, take: Int, where: OperationWhereInput): [Operation!]!
  findUniqueAccount(where: AccountWhereUniqueInput): Account
  findUniqueCategory(where: CategoryWhereUniqueInput): Category
  me: User
}

enum QueryMode {
  default
  insensitive
}

input RegisterInput {
  birthday: Date
  currency: Currency
  email: String!
  firstName: String!
  language: Locale
  lastName: String!
  password: String!
}

enum SortOrder {
  asc
  desc
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

type Subscription {
  userSignedIn(userId: String!): User
  userUpdated(userId: String!): User
}

enum TransactionType {
  CreditCard
  Deposit
  FixedExpense
  VariableExpense
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

type User {
  accounts(after: AccountWhereUniqueInput, before: AccountWhereUniqueInput, first: Int, last: Int, orderBy: [AccountOrderByInput!], where: AccountWhereInput): [Account!]!
  birthDay: DateTime
  categories(after: CategoryWhereUniqueInput, before: CategoryWhereUniqueInput, first: Int, last: Int, orderBy: [CategoryOrderByInput!], where: CategoryWhereInput): [Category!]!
  createdAt: DateTime!
  deletedAt: DateTime
  email: String!
  firstName: String!
  hasVerifiedEmail: Boolean!
  id: String!
  language: Locale!
  lastName: String!
  operations(after: OperationWhereUniqueInput, before: OperationWhereUniqueInput, first: Int, last: Int, orderBy: [OperationOrderByInput!], where: OperationWhereInput): [Operation!]!
  updatedAt: DateTime!
}

input UserOrderByInput {
  birthDay: SortOrder
  createdAt: SortOrder
  deletedAt: SortOrder
  email: SortOrder
  firstName: SortOrder
  hashToChangePassword: SortOrder
  hashToVerifyEmail: SortOrder
  hasVerifiedEmail: SortOrder
  id: SortOrder
  language: SortOrder
  lastName: SortOrder
  password: SortOrder
  updatedAt: SortOrder
}

input UserUpdateInput {
  birthday: Date
  email: String
  language: Locale
  name: String
  nickname: String
  phone: String
}

input UserWhereInput {
  accounts: AccountListRelationFilter
  AND: [UserWhereInput!]
  birthDay: DateTimeNullableFilter
  categories: CategoryListRelationFilter
  createdAt: DateTimeFilter
  creditCards: CreditCardListRelationFilter
  deletedAt: DateTimeNullableFilter
  email: StringFilter
  firstName: StringFilter
  hashToChangePassword: StringNullableFilter
  hashToVerifyEmail: StringNullableFilter
  hasVerifiedEmail: BoolFilter
  id: StringFilter
  language: EnumLocaleFilter
  lastName: StringFilter
  NOT: [UserWhereInput!]
  operations: OperationListRelationFilter
  OR: [UserWhereInput!]
  password: StringFilter
  updatedAt: DateTimeFilter
}
